# ═══════════════════════════════════════════════════════════════════════
# Task 1 – Code Analysis (populates shared memory)
# ═══════════════════════════════════════════════════════════════════════
code_analysis_task:
  description: >
    CALL the "Code Analyzer" tool with folder_path="{folder_path}".

    This will parse the entire codebase, build AST trees for every source
    file, detect the primary language, and store all parsed data in shared
    memory.

    After the tool finishes, CALL the "Shared Memory Reader" tool with
    key="summary" to verify what was stored.

    Then output a brief summary of:
    - Primary language detected
    - Number of source files parsed
    - Number of classes, functions, and imports found
    - Entry points identified
    - Config/build files found
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your summary before finalizing
    - Call: guardrails.validate_output(content="your_summary_output", output_type="markdown")
    - If any issues are found, fix them before returning final output
  expected_output: >
    A concise summary of the codebase analysis confirming that all data
    has been stored in shared memory. Include counts of files, classes,
    functions, imports, and entry points.
  agent: code_analyzer

# ═══════════════════════════════════════════════════════════════════════
# Task 2 – API Semantics Extraction
# ═══════════════════════════════════════════════════════════════════════
api_semantics_task:
  description: >
    CRITICAL: Extract ALL API endpoints. Do NOT miss any endpoints.

    Use the "Shared Memory Reader" tool to read:
    - key="classes" to get all class definitions with decorators
    - key="functions" to get all function definitions
    - key="annotations" to get all annotations/decorators (REST, HTTP, etc.)
    - key="source_files" to read controller/route files directly
    - key="ast_data" for full AST details

    MANDATORY STEPS:
    1. List ALL classes with @RestController, @Controller, @Service decorators
    2. For EACH class, list ALL methods with @GetMapping, @PostMapping, 
       @PutMapping, @DeleteMapping, @PatchMapping, @RequestMapping decorators
    3. For EACH endpoint, extract:
       - HTTP Method (GET, POST, PUT, DELETE, PATCH)
       - Full URL path (base path + method path)
       - Method description/purpose
       - ALL parameters: @PathVariable, @RequestParam, @RequestBody with types
       - Response: status codes, response body type/schema
       - Security: @PreAuthorize, @Secured, authentication requirements
       - Source file and line number

    QUALITY CHECKS:
    - Verify no endpoints are missing by cross-checking class count
    - Ensure all path variables are documented
    - Confirm all request/response types are specified
    - Do NOT hallucinate endpoints that don't exist in code
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your output before finalizing
    - Call: guardrails.validate_output(content="your_markdown_output", output_type="markdown")
    - If any issues are found, fix them before returning final output
    - Ensure no sensitive data (API keys, passwords) is exposed

    Output format: MARKDOWN with summary table + detailed endpoint sections.
    Keep output under 15,000 characters by using concise descriptions.
  expected_output: >
    Complete MARKDOWN API reference with all endpoints, methods, paths,
    parameters, responses, and security requirements. Every endpoint must
    be documented with full details. Output ONLY valid MARKDOWN.
  agent: api_semantics_agent

# ═══════════════════════════════════════════════════════════════════════
# Task 3 – Architecture Analysis (runs in parallel with Task 2)
# ═══════════════════════════════════════════════════════════════════════
architecture_reasoning_task:
  description: >
    CRITICAL: Document the complete system architecture. Do NOT miss layers or components.

    Use the "Shared Memory Reader" tool to read:
    - key="ast_data" for full AST details of every file
    - key="imports" for all import relationships and dependencies
    - key="classes" for class hierarchy and inheritance
    - key="functions" for all functions and their purposes
    - key="config_files" for build/config files (pom.xml, application.yml, etc.)
    - key="entry_points" for application entry points and main classes
    - key="packages" for build tool, dependencies, and versions
    - key="file_tree" for the complete directory structure

    MANDATORY ANALYSIS:
    1. **Identify ALL layers/components:**
       - Controllers/Routes (HTTP entry points)
       - Services/Business logic
       - Repositories/Data access
       - Models/Entities/DTOs
       - Utilities/Helpers
       - Configuration classes
       - Security/Authentication components
       - Database/ORM setup

    2. **Document relationships:**
       - Controller → Service dependencies
       - Service → Repository dependencies
       - Model/Entity definitions
       - Dependency injection setup
       - Configuration beans

    3. **Create Mermaid diagram showing:**
       - All identified components as boxes
       - Arrows showing dependencies
       - Clear layer separation
       - External integrations (DB, APIs, etc.)

    4. **Architecture narrative covering:**
       - Overall pattern (MVC, Layered, Microservices, etc.)
       - Each layer's responsibility
       - Request flow from entry to response
       - Data persistence strategy
       - Security mechanisms
       - Design patterns observed

    QUALITY CHECKS:
    - Verify all classes are accounted for in architecture
    - Ensure no components are missing
    - Confirm all dependencies are shown
    - Do NOT hallucinate components not in code
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your output before finalizing
    - Call: guardrails.validate_output(content="your_markdown_output", output_type="markdown")
    - If any issues are found, fix them before returning final output
    - Check for hallucination risks in architecture descriptions

    Output format: MARKDOWN with Mermaid diagram + detailed sections.
    Keep under 12,000 characters by focusing on essential architecture.
  expected_output: >
    MARKDOWN architecture document with Mermaid diagram showing all
    components and their relationships, plus detailed narrative of system
    design, layers, data flow, and patterns. Output ONLY valid MARKDOWN.
  agent: architecture_reasoning_agent

# ═══════════════════════════════════════════════════════════════════════
# Task 4 – Examples Generation (depends on API Semantics)
# ═══════════════════════════════════════════════════════════════════════
examples_generation_task:
  description: >
    CRITICAL: Generate examples for EVERY API endpoint. Do NOT skip any endpoints.

    Using the API reference from the API Semantics Agent (provided as context)
    and the shared memory data, generate practical examples.

    Use the "Shared Memory Reader" tool with key="source_files" to read
    actual controller code for request/response model details.

    MANDATORY FOR EACH ENDPOINT:
    1. **curl command** — Complete, copy-pastable, with all required headers
    2. **Request body** — Sample JSON with realistic, valid data
       - Include all required fields
       - Show correct data types
       - Use realistic values (not "test" or "foo")
    3. **Success response** — Sample JSON response with HTTP status code
       - Show actual response structure
       - Include all response fields
       - Correct status code (200, 201, 204, etc.)
    4. **Error response** — At least one error scenario
       - Show error response structure
       - Include error status code (400, 401, 404, 500, etc.)
       - Explain the error condition
    5. **Required headers** — Content-Type, Authorization, custom headers
       - Show exact header names and values
       - Explain authentication requirements

    QUALITY CHECKS:
    - Verify examples for ALL endpoints from API reference
    - Ensure curl commands are executable
    - Confirm all required parameters are shown
    - Validate JSON syntax in examples
    - Do NOT hallucinate examples for missing endpoints
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your output before finalizing
    - Call: guardrails.validate_output(content="your_markdown_output", output_type="markdown")
    - Use guardrails.redact() to ensure no real credentials are exposed
    - If any issues are found, fix them before returning final output

    Use placeholder values for secrets: "your-token-here", "your-api-key".
    Output format: MARKDOWN with fenced code blocks. Keep under 10,000 chars.
  expected_output: >
    MARKDOWN document with practical, runnable examples for EVERY API endpoint
    including curl commands, request/response bodies, headers, and error cases.
    Output ONLY valid MARKDOWN. Keep under 10,000 characters.
  agent: example_generator_agent

# ═══════════════════════════════════════════════════════════════════════
# Task 5 – Getting Started Guide (depends on Architecture)
# ═══════════════════════════════════════════════════════════════════════
getting_started_task:
  description: >
    CRITICAL: Create a complete Getting Started guide. Do NOT omit setup steps.

    Using the architecture overview from the Architecture Agent (provided as
    context) and the shared memory data, generate a comprehensive setup guide.

    Use the "Shared Memory Reader" tool to read:
    - key="packages" for build tool (Maven, Gradle, npm, etc.), dependencies
    - key="config_files" for configuration files (pom.xml, application.yml, etc.)
    - key="entry_points" for main class and application startup
    - key="language" for primary language and version requirements
    - key="source_files" for any setup scripts or documentation
    
    Use the "config_parser" tool with folder_path="{folder_path}" to:
    - Extract detailed configuration from all config files
    - Get exact dependency versions and requirements
    - Identify build tools and their versions
    - Find environment variables and ports needed
    - Determine if Docker or database is required

    MANDATORY SECTIONS (in order):
    1. **Project Overview** — What this project does (1-2 paragraphs)
       - Core purpose and functionality
       - Technology stack summary
    
    2. **Prerequisites** — Required software with SPECIFIC versions
       - Java/Node/Python version (e.g., "Java 11 or higher")
       - Build tool (Maven 3.6+, Gradle 7.0+, etc.)
       - Database (MySQL 8.0, PostgreSQL 12+, etc.)
       - Other tools (Git, Docker, etc.)
    
    3. **Installation** — Step-by-step instructions
       - Clone repository with git command
       - Install dependencies (mvn install, npm install, etc.)
       - Build project (mvn clean package, etc.)
       - Any additional setup steps
    
    4. **Configuration** — How to configure the application
       - Environment variables needed (list with examples)
       - Configuration files to modify (application.yml, .env, etc.)
       - Database setup (create DB, run migrations, etc.)
       - API keys or credentials setup
    
    5. **Running the Application** — How to start it
       - Exact command to run (java -jar, npm start, etc.)
       - Expected output when running successfully
       - Port and URL where it runs (http://localhost:8080)
    
    6. **Running Tests** — How to execute tests
       - Command to run all tests
       - Command to run specific test suites
       - Expected test results
    
    7. **Quick Start** — First API call
       - Link to Examples document
       - One simple curl example to verify setup
    
    8. **Project Structure** — Directory layout
       - Brief explanation of main directories
       - Where to find controllers, services, models, etc.
    
    9. **Troubleshooting** — Common issues and solutions
       - Port already in use
       - Database connection issues
       - Build failures
       - Other common problems

    QUALITY CHECKS:
    - Verify all prerequisites are listed with versions
    - Ensure installation steps are complete and in order
    - Confirm all configuration requirements are documented
    - Check that commands are exact and executable
    - Do NOT hallucinate setup steps not in actual code
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your output before finalizing
    - Call: guardrails.validate_output(content="your_markdown_output", output_type="markdown")
    - Use guardrails.redact() to ensure no real credentials are exposed
    - If any issues are found, fix them before returning final output

    Output format: MARKDOWN tutorial. Keep under 8,000 characters by being
    concise but complete in each section.
  expected_output: >
    Complete MARKDOWN Getting Started guide with all sections: overview,
    prerequisites with versions, installation steps, configuration, running
    instructions, tests, quick start, project structure, and troubleshooting.
    Output ONLY valid MARKDOWN. Keep under 8,000 characters.
  agent: getting_started_agent

# ═══════════════════════════════════════════════════════════════════════
# Task 6 – Document Assembly (final task, depends on all previous)
# ═══════════════════════════════════════════════════════════════════════
document_assembly_task:
  description: >
    You have the outputs from ALL previous agents as context.
    Assemble them into the final documentation suite.

    CONTEXT COMPRESSION STRATEGY:
    - Upstream agents have already limited their output to 8k-15k chars each
    - You will receive summaries, not full raw data
    - Focus on assembling these summaries cleanly with section markers
    - Do NOT expand or regenerate content — use what you receive as-is
    
    Produce a SINGLE output with clear section separators using this
    EXACT format:

    ===SECTION: README.md===
    [Getting Started Agent output — project overview + setup guide]

    ===SECTION: API_REFERENCE.md===
    [API Semantics Agent output — complete API reference]

    ===SECTION: ARCHITECTURE.md===
    [Architecture Agent output — system design + Mermaid diagram]

    ===SECTION: EXAMPLES.md===
    [Examples Agent output — code samples for all endpoints]

    ===SECTION: architecture.mermaid===
    [Extract ONLY the raw Mermaid diagram code from the Architecture
    output — no markdown fences, just the Mermaid syntax]

    RULES:
    - Use the content from each agent as provided — do NOT expand or regenerate
    - Add a brief table of contents to README.md linking to other docs
    - Add cross-reference links between documents (e.g., "See [API Reference](API_REFERENCE.md)")
    - Ensure every section separator is on its own line
    - The architecture.mermaid section should contain ONLY valid Mermaid syntax
    - Keep your total output under 50,000 characters
    
    GUARDRAINS VALIDATION:
    - Use the "guardrails" tool to validate your final output before returning
    - Call: guardrails.validate_output(content="your_full_document_output", output_type="markdown")
    - Use guardrails.check_quality() with expected_sections=["README", "API Reference", "Architecture", "Examples", "Test Documentation"]
    - If any issues are found, fix them before returning final output
    - Ensure no sensitive data is exposed in any section
  expected_output: >
    A single document containing all six sections separated by
    ===SECTION: filename=== markers. Each section contains the
    Output ONLY valid MARKDOWN with section separators. Keep under 60k chars.
  agent: document_assembler
